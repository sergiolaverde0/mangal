/*
MangaUpdates API

This API powers our website. Most API functions are public and do not require an account. For user-based functions, you must register an account. Currently, user registration must be done through our main website and is disabled via this API.  Download OpenAPI Specification: [openapi.yaml](openapi.yaml)  Please contact us at the following emails if you have questions:  * lambchopsil@mangaupdates.com * manick@mangaupdates.com  ## Warranties  MangaUpdates makes no warranties about service availability, correctness of the data, or anything else. The service is provided as is, and may change at any time.  ## Acceptable Use Policy  * You will credit MangaUpdates when using data provided by this API. * You will use reasonable spacing between requests so as not to overwhelm the MangaUpdates servers, and employ caching mechanisms when accessing data. * You will NOT use MangaUpdates data or API in a way that will:     * Deceive or defraud users     * Assist or perform an illegal action     * Create spam     * Damage the database  We reserve the right to change this policy at any time.

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"os"
	"strings"
)

// ForumAPIService ForumAPI service
type ForumAPIService service

type ApiAddForumAdminRequest struct {
	ctx        context.Context
	ApiService *ForumAPIService
	forumId    int64
	userId     int64
}

func (r ApiAddForumAdminRequest) Execute() (*ApiResponseV1, *http.Response, error) {
	return r.ApiService.AddForumAdminExecute(r)
}

/*
AddForumAdmin add a forum admin

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param forumId Forum id
	@param userId User id
	@return ApiAddForumAdminRequest
*/
func (a *ForumAPIService) AddForumAdmin(ctx context.Context, forumId int64, userId int64) ApiAddForumAdminRequest {
	return ApiAddForumAdminRequest{
		ApiService: a,
		ctx:        ctx,
		forumId:    forumId,
		userId:     userId,
	}
}

// Execute executes the request
//
//	@return ApiResponseV1
func (a *ForumAPIService) AddForumAdminExecute(r ApiAddForumAdminRequest) (*ApiResponseV1, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApiResponseV1
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ForumAPIService.AddForumAdmin")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/forums/{forum_id}/admins/{user_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"forum_id"+"}", url.PathEscape(parameterValueToString(r.forumId, "forumId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiResponseV1
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddPollVoteRequest struct {
	ctx        context.Context
	ApiService *ForumAPIService
	forumId    int64
	topicId    int64
	choiceId   int64
}

func (r ApiAddPollVoteRequest) Execute() (*ApiResponseV1, *http.Response, error) {
	return r.ApiService.AddPollVoteExecute(r)
}

/*
AddPollVote add a vote to a forum poll

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param forumId Forum id
	@param topicId Topic id
	@param choiceId Choice id
	@return ApiAddPollVoteRequest
*/
func (a *ForumAPIService) AddPollVote(ctx context.Context, forumId int64, topicId int64, choiceId int64) ApiAddPollVoteRequest {
	return ApiAddPollVoteRequest{
		ApiService: a,
		ctx:        ctx,
		forumId:    forumId,
		topicId:    topicId,
		choiceId:   choiceId,
	}
}

// Execute executes the request
//
//	@return ApiResponseV1
func (a *ForumAPIService) AddPollVoteExecute(r ApiAddPollVoteRequest) (*ApiResponseV1, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApiResponseV1
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ForumAPIService.AddPollVote")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/forums/{forum_id}/topics/{topic_id}/poll/vote/{choice_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"forum_id"+"}", url.PathEscape(parameterValueToString(r.forumId, "forumId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic_id"+"}", url.PathEscape(parameterValueToString(r.topicId, "topicId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"choice_id"+"}", url.PathEscape(parameterValueToString(r.choiceId, "choiceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponseV1
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddPostRequest struct {
	ctx                    context.Context
	ApiService             *ForumAPIService
	forumId                int64
	topicId                int64
	forumPostModelUpdateV1 *ForumPostModelUpdateV1
}

func (r ApiAddPostRequest) ForumPostModelUpdateV1(forumPostModelUpdateV1 ForumPostModelUpdateV1) ApiAddPostRequest {
	r.forumPostModelUpdateV1 = &forumPostModelUpdateV1
	return r
}

func (r ApiAddPostRequest) Execute() (*ApiResponseV1, *http.Response, error) {
	return r.ApiService.AddPostExecute(r)
}

/*
AddPost add a forum post

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param forumId Forum id
	@param topicId Topic id
	@return ApiAddPostRequest
*/
func (a *ForumAPIService) AddPost(ctx context.Context, forumId int64, topicId int64) ApiAddPostRequest {
	return ApiAddPostRequest{
		ApiService: a,
		ctx:        ctx,
		forumId:    forumId,
		topicId:    topicId,
	}
}

// Execute executes the request
//
//	@return ApiResponseV1
func (a *ForumAPIService) AddPostExecute(r ApiAddPostRequest) (*ApiResponseV1, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApiResponseV1
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ForumAPIService.AddPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/forums/{forum_id}/topics/{topic_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"forum_id"+"}", url.PathEscape(parameterValueToString(r.forumId, "forumId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic_id"+"}", url.PathEscape(parameterValueToString(r.topicId, "topicId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.forumPostModelUpdateV1 == nil {
		return localVarReturnValue, nil, reportError("forumPostModelUpdateV1 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.forumPostModelUpdateV1
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponseV1
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddTemporaryPollImageRequest struct {
	ctx        context.Context
	ApiService *ForumAPIService
	image      *os.File
	caption    *string
}

// Image to update
func (r ApiAddTemporaryPollImageRequest) Image(image *os.File) ApiAddTemporaryPollImageRequest {
	r.image = image
	return r
}

// Image caption
func (r ApiAddTemporaryPollImageRequest) Caption(caption string) ApiAddTemporaryPollImageRequest {
	r.caption = &caption
	return r
}

func (r ApiAddTemporaryPollImageRequest) Execute() (*ApiResponseV1, *http.Response, error) {
	return r.ApiService.AddTemporaryPollImageExecute(r)
}

/*
AddTemporaryPollImage add a temporary poll image

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAddTemporaryPollImageRequest
*/
func (a *ForumAPIService) AddTemporaryPollImage(ctx context.Context) ApiAddTemporaryPollImageRequest {
	return ApiAddTemporaryPollImageRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ApiResponseV1
func (a *ForumAPIService) AddTemporaryPollImageExecute(r ApiAddTemporaryPollImageRequest) (*ApiResponseV1, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApiResponseV1
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ForumAPIService.AddTemporaryPollImage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/forums/temp_poll_images"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var imageLocalVarFormFileName string
	var imageLocalVarFileName string
	var imageLocalVarFileBytes []byte

	imageLocalVarFormFileName = "image"

	imageLocalVarFile := r.image

	if imageLocalVarFile != nil {
		fbs, _ := io.ReadAll(imageLocalVarFile)

		imageLocalVarFileBytes = fbs
		imageLocalVarFileName = imageLocalVarFile.Name()
		imageLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: imageLocalVarFileBytes, fileName: imageLocalVarFileName, formFileName: imageLocalVarFormFileName})
	}
	if r.caption != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "caption", r.caption, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponseV1
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddTopicRequest struct {
	ctx                  context.Context
	ApiService           *ForumAPIService
	forumId              int64
	forumTopicModelAddV1 *ForumTopicModelAddV1
}

func (r ApiAddTopicRequest) ForumTopicModelAddV1(forumTopicModelAddV1 ForumTopicModelAddV1) ApiAddTopicRequest {
	r.forumTopicModelAddV1 = &forumTopicModelAddV1
	return r
}

func (r ApiAddTopicRequest) Execute() (*ApiResponseV1, *http.Response, error) {
	return r.ApiService.AddTopicExecute(r)
}

/*
AddTopic add a forum topic

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param forumId Forum id
	@return ApiAddTopicRequest
*/
func (a *ForumAPIService) AddTopic(ctx context.Context, forumId int64) ApiAddTopicRequest {
	return ApiAddTopicRequest{
		ApiService: a,
		ctx:        ctx,
		forumId:    forumId,
	}
}

// Execute executes the request
//
//	@return ApiResponseV1
func (a *ForumAPIService) AddTopicExecute(r ApiAddTopicRequest) (*ApiResponseV1, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApiResponseV1
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ForumAPIService.AddTopic")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/forums/{forum_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"forum_id"+"}", url.PathEscape(parameterValueToString(r.forumId, "forumId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.forumTopicModelAddV1 == nil {
		return localVarReturnValue, nil, reportError("forumTopicModelAddV1 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.forumTopicModelAddV1
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponseV1
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeletePostRequest struct {
	ctx        context.Context
	ApiService *ForumAPIService
	forumId    int64
	topicId    int64
	postId     int64
}

func (r ApiDeletePostRequest) Execute() (*ApiResponseV1, *http.Response, error) {
	return r.ApiService.DeletePostExecute(r)
}

/*
DeletePost delete a post

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param forumId Forum id
	@param topicId Topic id
	@param postId Post id
	@return ApiDeletePostRequest
*/
func (a *ForumAPIService) DeletePost(ctx context.Context, forumId int64, topicId int64, postId int64) ApiDeletePostRequest {
	return ApiDeletePostRequest{
		ApiService: a,
		ctx:        ctx,
		forumId:    forumId,
		topicId:    topicId,
		postId:     postId,
	}
}

// Execute executes the request
//
//	@return ApiResponseV1
func (a *ForumAPIService) DeletePostExecute(r ApiDeletePostRequest) (*ApiResponseV1, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApiResponseV1
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ForumAPIService.DeletePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/forums/{forum_id}/topics/{topic_id}/posts/{post_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"forum_id"+"}", url.PathEscape(parameterValueToString(r.forumId, "forumId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic_id"+"}", url.PathEscape(parameterValueToString(r.topicId, "topicId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post_id"+"}", url.PathEscape(parameterValueToString(r.postId, "postId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponseV1
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeletePostReportRequest struct {
	ctx        context.Context
	ApiService *ForumAPIService
	forumId    int64
	topicId    int64
	postId     int64
}

func (r ApiDeletePostReportRequest) Execute() (*ApiResponseV1, *http.Response, error) {
	return r.ApiService.DeletePostReportExecute(r)
}

/*
DeletePostReport delete a post report

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param forumId Forum id
	@param topicId Topic id
	@param postId Post id
	@return ApiDeletePostReportRequest
*/
func (a *ForumAPIService) DeletePostReport(ctx context.Context, forumId int64, topicId int64, postId int64) ApiDeletePostReportRequest {
	return ApiDeletePostReportRequest{
		ApiService: a,
		ctx:        ctx,
		forumId:    forumId,
		topicId:    topicId,
		postId:     postId,
	}
}

// Execute executes the request
//
//	@return ApiResponseV1
func (a *ForumAPIService) DeletePostReportExecute(r ApiDeletePostReportRequest) (*ApiResponseV1, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApiResponseV1
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ForumAPIService.DeletePostReport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/forums/{forum_id}/topics/{topic_id}/posts/{post_id}/report"
	localVarPath = strings.Replace(localVarPath, "{"+"forum_id"+"}", url.PathEscape(parameterValueToString(r.forumId, "forumId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic_id"+"}", url.PathEscape(parameterValueToString(r.topicId, "topicId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post_id"+"}", url.PathEscape(parameterValueToString(r.postId, "postId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponseV1
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteTopicRequest struct {
	ctx        context.Context
	ApiService *ForumAPIService
	forumId    int64
	topicId    int64
}

func (r ApiDeleteTopicRequest) Execute() (*ApiResponseV1, *http.Response, error) {
	return r.ApiService.DeleteTopicExecute(r)
}

/*
DeleteTopic delete a topic

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param forumId Forum id
	@param topicId Topic id
	@return ApiDeleteTopicRequest
*/
func (a *ForumAPIService) DeleteTopic(ctx context.Context, forumId int64, topicId int64) ApiDeleteTopicRequest {
	return ApiDeleteTopicRequest{
		ApiService: a,
		ctx:        ctx,
		forumId:    forumId,
		topicId:    topicId,
	}
}

// Execute executes the request
//
//	@return ApiResponseV1
func (a *ForumAPIService) DeleteTopicExecute(r ApiDeleteTopicRequest) (*ApiResponseV1, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApiResponseV1
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ForumAPIService.DeleteTopic")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/forums/{forum_id}/topics/{topic_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"forum_id"+"}", url.PathEscape(parameterValueToString(r.forumId, "forumId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic_id"+"}", url.PathEscape(parameterValueToString(r.topicId, "topicId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponseV1
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCurrentWarnForUserRequest struct {
	ctx        context.Context
	ApiService *ForumAPIService
	userId     int64
}

func (r ApiGetCurrentWarnForUserRequest) Execute() (*ForumWarnModelV1, *http.Response, error) {
	return r.ApiService.GetCurrentWarnForUserExecute(r)
}

/*
GetCurrentWarnForUser gets the current warn status for user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId User id
	@return ApiGetCurrentWarnForUserRequest
*/
func (a *ForumAPIService) GetCurrentWarnForUser(ctx context.Context, userId int64) ApiGetCurrentWarnForUserRequest {
	return ApiGetCurrentWarnForUserRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
	}
}

// Execute executes the request
//
//	@return ForumWarnModelV1
func (a *ForumAPIService) GetCurrentWarnForUserExecute(r ApiGetCurrentWarnForUserRequest) (*ForumWarnModelV1, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ForumWarnModelV1
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ForumAPIService.GetCurrentWarnForUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/forums/warn/{user_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListCategoriesRequest struct {
	ctx        context.Context
	ApiService *ForumAPIService
}

func (r ApiListCategoriesRequest) Execute() ([]ForumCategoryModelListV1, *http.Response, error) {
	return r.ApiService.ListCategoriesExecute(r)
}

/*
ListCategories show forum categories and forums

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListCategoriesRequest
*/
func (a *ForumAPIService) ListCategories(ctx context.Context) ApiListCategoriesRequest {
	return ApiListCategoriesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []ForumCategoryModelListV1
func (a *ForumAPIService) ListCategoriesExecute(r ApiListCategoriesRequest) ([]ForumCategoryModelListV1, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []ForumCategoryModelListV1
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ForumAPIService.ListCategories")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/forums"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListGlobalTopicsRequest struct {
	ctx        context.Context
	ApiService *ForumAPIService
}

func (r ApiListGlobalTopicsRequest) Execute() (*ForumTopicListResponseV1, *http.Response, error) {
	return r.ApiService.ListGlobalTopicsExecute(r)
}

/*
ListGlobalTopics list global topics

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListGlobalTopicsRequest
*/
func (a *ForumAPIService) ListGlobalTopics(ctx context.Context) ApiListGlobalTopicsRequest {
	return ApiListGlobalTopicsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ForumTopicListResponseV1
func (a *ForumAPIService) ListGlobalTopicsExecute(r ApiListGlobalTopicsRequest) (*ForumTopicListResponseV1, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ForumTopicListResponseV1
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ForumAPIService.ListGlobalTopics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/forums/global"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListPopularForumsRequest struct {
	ctx        context.Context
	ApiService *ForumAPIService
}

func (r ApiListPopularForumsRequest) Execute() ([]ForumForumModelListV1, *http.Response, error) {
	return r.ApiService.ListPopularForumsExecute(r)
}

/*
ListPopularForums show popular forums

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListPopularForumsRequest
*/
func (a *ForumAPIService) ListPopularForums(ctx context.Context) ApiListPopularForumsRequest {
	return ApiListPopularForumsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []ForumForumModelListV1
func (a *ForumAPIService) ListPopularForumsExecute(r ApiListPopularForumsRequest) ([]ForumForumModelListV1, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []ForumForumModelListV1
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ForumAPIService.ListPopularForums")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/forums/popular"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListPostsRequest struct {
	ctx                    context.Context
	ApiService             *ForumAPIService
	forumId                int64
	topicId                int64
	perPageSearchRequestV1 *PerPageSearchRequestV1
}

func (r ApiListPostsRequest) PerPageSearchRequestV1(perPageSearchRequestV1 PerPageSearchRequestV1) ApiListPostsRequest {
	r.perPageSearchRequestV1 = &perPageSearchRequestV1
	return r
}

func (r ApiListPostsRequest) Execute() (*ForumPostListResponseV1, *http.Response, error) {
	return r.ApiService.ListPostsExecute(r)
}

/*
ListPosts list posts in topic

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param forumId Forum id
	@param topicId Topic id
	@return ApiListPostsRequest
*/
func (a *ForumAPIService) ListPosts(ctx context.Context, forumId int64, topicId int64) ApiListPostsRequest {
	return ApiListPostsRequest{
		ApiService: a,
		ctx:        ctx,
		forumId:    forumId,
		topicId:    topicId,
	}
}

// Execute executes the request
//
//	@return ForumPostListResponseV1
func (a *ForumAPIService) ListPostsExecute(r ApiListPostsRequest) (*ForumPostListResponseV1, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ForumPostListResponseV1
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ForumAPIService.ListPosts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/forums/{forum_id}/topics/{topic_id}/list"
	localVarPath = strings.Replace(localVarPath, "{"+"forum_id"+"}", url.PathEscape(parameterValueToString(r.forumId, "forumId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic_id"+"}", url.PathEscape(parameterValueToString(r.topicId, "topicId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.perPageSearchRequestV1 == nil {
		return localVarReturnValue, nil, reportError("perPageSearchRequestV1 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.perPageSearchRequestV1
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponseV1
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListPostsByMeRequest struct {
	ctx        context.Context
	ApiService *ForumAPIService
	forumId    int64
	topicId    int64
}

func (r ApiListPostsByMeRequest) Execute() (*ForumPostByUserResponseV1, *http.Response, error) {
	return r.ApiService.ListPostsByMeExecute(r)
}

/*
ListPostsByMe list posts in topic that I made

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param forumId Forum id
	@param topicId Topic id
	@return ApiListPostsByMeRequest
*/
func (a *ForumAPIService) ListPostsByMe(ctx context.Context, forumId int64, topicId int64) ApiListPostsByMeRequest {
	return ApiListPostsByMeRequest{
		ApiService: a,
		ctx:        ctx,
		forumId:    forumId,
		topicId:    topicId,
	}
}

// Execute executes the request
//
//	@return ForumPostByUserResponseV1
func (a *ForumAPIService) ListPostsByMeExecute(r ApiListPostsByMeRequest) (*ForumPostByUserResponseV1, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ForumPostByUserResponseV1
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ForumAPIService.ListPostsByMe")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/forums/{forum_id}/topics/{topic_id}/my_posts"
	localVarPath = strings.Replace(localVarPath, "{"+"forum_id"+"}", url.PathEscape(parameterValueToString(r.forumId, "forumId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic_id"+"}", url.PathEscape(parameterValueToString(r.topicId, "topicId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListReportedPostsRequest struct {
	ctx        context.Context
	ApiService *ForumAPIService
}

func (r ApiListReportedPostsRequest) Execute() ([]ForumPostReportModelV1, *http.Response, error) {
	return r.ApiService.ListReportedPostsExecute(r)
}

/*
ListReportedPosts show reported posts

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListReportedPostsRequest
*/
func (a *ForumAPIService) ListReportedPosts(ctx context.Context) ApiListReportedPostsRequest {
	return ApiListReportedPostsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []ForumPostReportModelV1
func (a *ForumAPIService) ListReportedPostsExecute(r ApiListReportedPostsRequest) ([]ForumPostReportModelV1, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []ForumPostReportModelV1
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ForumAPIService.ListReportedPosts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/forums/report"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListTopicsRequest struct {
	ctx                     context.Context
	ApiService              *ForumAPIService
	forumId                 int64
	forumTopicListRequestV1 *ForumTopicListRequestV1
	withFirstPost           *bool
}

func (r ApiListTopicsRequest) ForumTopicListRequestV1(forumTopicListRequestV1 ForumTopicListRequestV1) ApiListTopicsRequest {
	r.forumTopicListRequestV1 = &forumTopicListRequestV1
	return r
}

// Also return the first post of each topic
func (r ApiListTopicsRequest) WithFirstPost(withFirstPost bool) ApiListTopicsRequest {
	r.withFirstPost = &withFirstPost
	return r
}

func (r ApiListTopicsRequest) Execute() (*ForumTopicListResponseV1, *http.Response, error) {
	return r.ApiService.ListTopicsExecute(r)
}

/*
ListTopics list topics

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param forumId Forum id
	@return ApiListTopicsRequest
*/
func (a *ForumAPIService) ListTopics(ctx context.Context, forumId int64) ApiListTopicsRequest {
	return ApiListTopicsRequest{
		ApiService: a,
		ctx:        ctx,
		forumId:    forumId,
	}
}

// Execute executes the request
//
//	@return ForumTopicListResponseV1
func (a *ForumAPIService) ListTopicsExecute(r ApiListTopicsRequest) (*ForumTopicListResponseV1, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ForumTopicListResponseV1
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ForumAPIService.ListTopics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/forums/{forum_id}/list"
	localVarPath = strings.Replace(localVarPath, "{"+"forum_id"+"}", url.PathEscape(parameterValueToString(r.forumId, "forumId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.forumTopicListRequestV1 == nil {
		return localVarReturnValue, nil, reportError("forumTopicListRequestV1 is required and must be specified")
	}

	if r.withFirstPost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_first_post", r.withFirstPost, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.forumTopicListRequestV1
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponseV1
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListWarnHistoryForUserRequest struct {
	ctx        context.Context
	ApiService *ForumAPIService
	userId     int64
}

func (r ApiListWarnHistoryForUserRequest) Execute() ([]ForumWarnModelV1, *http.Response, error) {
	return r.ApiService.ListWarnHistoryForUserExecute(r)
}

/*
ListWarnHistoryForUser show warn history for a user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId User id
	@return ApiListWarnHistoryForUserRequest
*/
func (a *ForumAPIService) ListWarnHistoryForUser(ctx context.Context, userId int64) ApiListWarnHistoryForUserRequest {
	return ApiListWarnHistoryForUserRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
	}
}

// Execute executes the request
//
//	@return []ForumWarnModelV1
func (a *ForumAPIService) ListWarnHistoryForUserExecute(r ApiListWarnHistoryForUserRequest) ([]ForumWarnModelV1, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []ForumWarnModelV1
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ForumAPIService.ListWarnHistoryForUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/forums/warn/{user_id}/history"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLookupPostRequest struct {
	ctx        context.Context
	ApiService *ForumAPIService
	postId     int64
}

func (r ApiLookupPostRequest) Execute() (*ForumLookupResponseV1, *http.Response, error) {
	return r.ApiService.LookupPostExecute(r)
}

/*
LookupPost lookup a post to find the forum and topic id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param postId Post id
	@return ApiLookupPostRequest
*/
func (a *ForumAPIService) LookupPost(ctx context.Context, postId int64) ApiLookupPostRequest {
	return ApiLookupPostRequest{
		ApiService: a,
		ctx:        ctx,
		postId:     postId,
	}
}

// Execute executes the request
//
//	@return ForumLookupResponseV1
func (a *ForumAPIService) LookupPostExecute(r ApiLookupPostRequest) (*ForumLookupResponseV1, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ForumLookupResponseV1
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ForumAPIService.LookupPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/forums/lookup/post/{post_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"post_id"+"}", url.PathEscape(parameterValueToString(r.postId, "postId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLookupSeriesRequest struct {
	ctx        context.Context
	ApiService *ForumAPIService
	seriesId   int64
}

func (r ApiLookupSeriesRequest) Execute() (*ForumLookupResponseV1, *http.Response, error) {
	return r.ApiService.LookupSeriesExecute(r)
}

/*
LookupSeries lookup a series to find the forum id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param seriesId Series id
	@return ApiLookupSeriesRequest
*/
func (a *ForumAPIService) LookupSeries(ctx context.Context, seriesId int64) ApiLookupSeriesRequest {
	return ApiLookupSeriesRequest{
		ApiService: a,
		ctx:        ctx,
		seriesId:   seriesId,
	}
}

// Execute executes the request
//
//	@return ForumLookupResponseV1
func (a *ForumAPIService) LookupSeriesExecute(r ApiLookupSeriesRequest) (*ForumLookupResponseV1, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ForumLookupResponseV1
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ForumAPIService.LookupSeries")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/forums/lookup/series/{series_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"series_id"+"}", url.PathEscape(parameterValueToString(r.seriesId, "seriesId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLookupTopicRequest struct {
	ctx        context.Context
	ApiService *ForumAPIService
	topicId    int64
}

func (r ApiLookupTopicRequest) Execute() (*ForumLookupResponseV1, *http.Response, error) {
	return r.ApiService.LookupTopicExecute(r)
}

/*
LookupTopic lookup a topic to find the forum id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param topicId Topic id
	@return ApiLookupTopicRequest
*/
func (a *ForumAPIService) LookupTopic(ctx context.Context, topicId int64) ApiLookupTopicRequest {
	return ApiLookupTopicRequest{
		ApiService: a,
		ctx:        ctx,
		topicId:    topicId,
	}
}

// Execute executes the request
//
//	@return ForumLookupResponseV1
func (a *ForumAPIService) LookupTopicExecute(r ApiLookupTopicRequest) (*ForumLookupResponseV1, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ForumLookupResponseV1
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ForumAPIService.LookupTopic")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/forums/lookup/topic/{topic_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"topic_id"+"}", url.PathEscape(parameterValueToString(r.topicId, "topicId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveForumAdminRequest struct {
	ctx        context.Context
	ApiService *ForumAPIService
	forumId    int64
	userId     int64
}

func (r ApiRemoveForumAdminRequest) Execute() (*ApiResponseV1, *http.Response, error) {
	return r.ApiService.RemoveForumAdminExecute(r)
}

/*
RemoveForumAdmin remove a forum admin

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param forumId Forum id
	@param userId User id
	@return ApiRemoveForumAdminRequest
*/
func (a *ForumAPIService) RemoveForumAdmin(ctx context.Context, forumId int64, userId int64) ApiRemoveForumAdminRequest {
	return ApiRemoveForumAdminRequest{
		ApiService: a,
		ctx:        ctx,
		forumId:    forumId,
		userId:     userId,
	}
}

// Execute executes the request
//
//	@return ApiResponseV1
func (a *ForumAPIService) RemoveForumAdminExecute(r ApiRemoveForumAdminRequest) (*ApiResponseV1, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApiResponseV1
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ForumAPIService.RemoveForumAdmin")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/forums/{forum_id}/admins/{user_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"forum_id"+"}", url.PathEscape(parameterValueToString(r.forumId, "forumId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiResponseV1
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReportPostRequest struct {
	ctx                          context.Context
	ApiService                   *ForumAPIService
	forumId                      int64
	topicId                      int64
	postId                       int64
	forumPostReportModelUpdateV1 *ForumPostReportModelUpdateV1
}

func (r ApiReportPostRequest) ForumPostReportModelUpdateV1(forumPostReportModelUpdateV1 ForumPostReportModelUpdateV1) ApiReportPostRequest {
	r.forumPostReportModelUpdateV1 = &forumPostReportModelUpdateV1
	return r
}

func (r ApiReportPostRequest) Execute() (*ApiResponseV1, *http.Response, error) {
	return r.ApiService.ReportPostExecute(r)
}

/*
ReportPost report a forum post

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param forumId Forum id
	@param topicId Topic id
	@param postId Post id
	@return ApiReportPostRequest
*/
func (a *ForumAPIService) ReportPost(ctx context.Context, forumId int64, topicId int64, postId int64) ApiReportPostRequest {
	return ApiReportPostRequest{
		ApiService: a,
		ctx:        ctx,
		forumId:    forumId,
		topicId:    topicId,
		postId:     postId,
	}
}

// Execute executes the request
//
//	@return ApiResponseV1
func (a *ForumAPIService) ReportPostExecute(r ApiReportPostRequest) (*ApiResponseV1, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApiResponseV1
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ForumAPIService.ReportPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/forums/{forum_id}/topics/{topic_id}/posts/{post_id}/report"
	localVarPath = strings.Replace(localVarPath, "{"+"forum_id"+"}", url.PathEscape(parameterValueToString(r.forumId, "forumId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic_id"+"}", url.PathEscape(parameterValueToString(r.topicId, "topicId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post_id"+"}", url.PathEscape(parameterValueToString(r.postId, "postId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.forumPostReportModelUpdateV1 == nil {
		return localVarReturnValue, nil, reportError("forumPostReportModelUpdateV1 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.forumPostReportModelUpdateV1
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponseV1
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRetrieveForumRequest struct {
	ctx              context.Context
	ApiService       *ForumAPIService
	forumId          int64
	unrenderedFields *bool
}

// Output fields in unrendered form for editing
func (r ApiRetrieveForumRequest) UnrenderedFields(unrenderedFields bool) ApiRetrieveForumRequest {
	r.unrenderedFields = &unrenderedFields
	return r
}

func (r ApiRetrieveForumRequest) Execute() (*ForumForumModelV1, *http.Response, error) {
	return r.ApiService.RetrieveForumExecute(r)
}

/*
RetrieveForum retrieve a forum

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param forumId Forum id
	@return ApiRetrieveForumRequest
*/
func (a *ForumAPIService) RetrieveForum(ctx context.Context, forumId int64) ApiRetrieveForumRequest {
	return ApiRetrieveForumRequest{
		ApiService: a,
		ctx:        ctx,
		forumId:    forumId,
	}
}

// Execute executes the request
//
//	@return ForumForumModelV1
func (a *ForumAPIService) RetrieveForumExecute(r ApiRetrieveForumRequest) (*ForumForumModelV1, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ForumForumModelV1
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ForumAPIService.RetrieveForum")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/forums/{forum_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"forum_id"+"}", url.PathEscape(parameterValueToString(r.forumId, "forumId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.unrenderedFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unrenderedFields", r.unrenderedFields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRetrievePostRequest struct {
	ctx              context.Context
	ApiService       *ForumAPIService
	forumId          int64
	topicId          int64
	postId           int64
	unrenderedFields *bool
}

// Output fields in unrendered form for editing
func (r ApiRetrievePostRequest) UnrenderedFields(unrenderedFields bool) ApiRetrievePostRequest {
	r.unrenderedFields = &unrenderedFields
	return r
}

func (r ApiRetrievePostRequest) Execute() (*ForumPostModelV1, *http.Response, error) {
	return r.ApiService.RetrievePostExecute(r)
}

/*
RetrievePost retrieve a forum post

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param forumId Forum id
	@param topicId Topic id
	@param postId Post id
	@return ApiRetrievePostRequest
*/
func (a *ForumAPIService) RetrievePost(ctx context.Context, forumId int64, topicId int64, postId int64) ApiRetrievePostRequest {
	return ApiRetrievePostRequest{
		ApiService: a,
		ctx:        ctx,
		forumId:    forumId,
		topicId:    topicId,
		postId:     postId,
	}
}

// Execute executes the request
//
//	@return ForumPostModelV1
func (a *ForumAPIService) RetrievePostExecute(r ApiRetrievePostRequest) (*ForumPostModelV1, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ForumPostModelV1
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ForumAPIService.RetrievePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/forums/{forum_id}/topics/{topic_id}/posts/{post_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"forum_id"+"}", url.PathEscape(parameterValueToString(r.forumId, "forumId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic_id"+"}", url.PathEscape(parameterValueToString(r.topicId, "topicId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post_id"+"}", url.PathEscape(parameterValueToString(r.postId, "postId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.unrenderedFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unrenderedFields", r.unrenderedFields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRetrievePostLocationRequest struct {
	ctx        context.Context
	ApiService *ForumAPIService
	forumId    int64
	topicId    int64
	postId     int64
}

func (r ApiRetrievePostLocationRequest) Execute() (*ApiResponseV1, *http.Response, error) {
	return r.ApiService.RetrievePostLocationExecute(r)
}

/*
RetrievePostLocation retrieve a forum post location within topic

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param forumId Forum id
	@param topicId Topic id
	@param postId Post id
	@return ApiRetrievePostLocationRequest
*/
func (a *ForumAPIService) RetrievePostLocation(ctx context.Context, forumId int64, topicId int64, postId int64) ApiRetrievePostLocationRequest {
	return ApiRetrievePostLocationRequest{
		ApiService: a,
		ctx:        ctx,
		forumId:    forumId,
		topicId:    topicId,
		postId:     postId,
	}
}

// Execute executes the request
//
//	@return ApiResponseV1
func (a *ForumAPIService) RetrievePostLocationExecute(r ApiRetrievePostLocationRequest) (*ApiResponseV1, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApiResponseV1
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ForumAPIService.RetrievePostLocation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/forums/{forum_id}/topics/{topic_id}/posts/{post_id}/location"
	localVarPath = strings.Replace(localVarPath, "{"+"forum_id"+"}", url.PathEscape(parameterValueToString(r.forumId, "forumId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic_id"+"}", url.PathEscape(parameterValueToString(r.topicId, "topicId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post_id"+"}", url.PathEscape(parameterValueToString(r.postId, "postId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRetrieveTemporaryPollImagesRequest struct {
	ctx        context.Context
	ApiService *ForumAPIService
}

func (r ApiRetrieveTemporaryPollImagesRequest) Execute() ([]ForumPollTempImageModelV1, *http.Response, error) {
	return r.ApiService.RetrieveTemporaryPollImagesExecute(r)
}

/*
RetrieveTemporaryPollImages retrieve temporary poll images

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiRetrieveTemporaryPollImagesRequest
*/
func (a *ForumAPIService) RetrieveTemporaryPollImages(ctx context.Context) ApiRetrieveTemporaryPollImagesRequest {
	return ApiRetrieveTemporaryPollImagesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []ForumPollTempImageModelV1
func (a *ForumAPIService) RetrieveTemporaryPollImagesExecute(r ApiRetrieveTemporaryPollImagesRequest) ([]ForumPollTempImageModelV1, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []ForumPollTempImageModelV1
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ForumAPIService.RetrieveTemporaryPollImages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/forums/temp_poll_images"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRetrieveTopicRequest struct {
	ctx              context.Context
	ApiService       *ForumAPIService
	forumId          int64
	topicId          int64
	unrenderedFields *bool
}

// Output fields in unrendered form for editing
func (r ApiRetrieveTopicRequest) UnrenderedFields(unrenderedFields bool) ApiRetrieveTopicRequest {
	r.unrenderedFields = &unrenderedFields
	return r
}

func (r ApiRetrieveTopicRequest) Execute() (*ForumTopicModelV1, *http.Response, error) {
	return r.ApiService.RetrieveTopicExecute(r)
}

/*
RetrieveTopic retrieve a forum topic

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param forumId Forum id
	@param topicId Topic id
	@return ApiRetrieveTopicRequest
*/
func (a *ForumAPIService) RetrieveTopic(ctx context.Context, forumId int64, topicId int64) ApiRetrieveTopicRequest {
	return ApiRetrieveTopicRequest{
		ApiService: a,
		ctx:        ctx,
		forumId:    forumId,
		topicId:    topicId,
	}
}

// Execute executes the request
//
//	@return ForumTopicModelV1
func (a *ForumAPIService) RetrieveTopicExecute(r ApiRetrieveTopicRequest) (*ForumTopicModelV1, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ForumTopicModelV1
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ForumAPIService.RetrieveTopic")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/forums/{forum_id}/topics/{topic_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"forum_id"+"}", url.PathEscape(parameterValueToString(r.forumId, "forumId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic_id"+"}", url.PathEscape(parameterValueToString(r.topicId, "topicId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.unrenderedFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unrenderedFields", r.unrenderedFields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRetrieveVoteRequest struct {
	ctx        context.Context
	ApiService *ForumAPIService
	forumId    int64
	topicId    int64
}

func (r ApiRetrieveVoteRequest) Execute() (*ForumPollVoteModelV1, *http.Response, error) {
	return r.ApiService.RetrieveVoteExecute(r)
}

/*
RetrieveVote retrieve my vote from the poll

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param forumId Forum id
	@param topicId Topic id
	@return ApiRetrieveVoteRequest
*/
func (a *ForumAPIService) RetrieveVote(ctx context.Context, forumId int64, topicId int64) ApiRetrieveVoteRequest {
	return ApiRetrieveVoteRequest{
		ApiService: a,
		ctx:        ctx,
		forumId:    forumId,
		topicId:    topicId,
	}
}

// Execute executes the request
//
//	@return ForumPollVoteModelV1
func (a *ForumAPIService) RetrieveVoteExecute(r ApiRetrieveVoteRequest) (*ForumPollVoteModelV1, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ForumPollVoteModelV1
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ForumAPIService.RetrieveVote")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/forums/{forum_id}/topics/{topic_id}/poll/vote"
	localVarPath = strings.Replace(localVarPath, "{"+"forum_id"+"}", url.PathEscape(parameterValueToString(r.forumId, "forumId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic_id"+"}", url.PathEscape(parameterValueToString(r.topicId, "topicId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiResponseV1
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchForumPostRequest struct {
	ctx                  context.Context
	ApiService           *ForumAPIService
	forumSearchRequestV1 *ForumSearchRequestV1
}

func (r ApiSearchForumPostRequest) ForumSearchRequestV1(forumSearchRequestV1 ForumSearchRequestV1) ApiSearchForumPostRequest {
	r.forumSearchRequestV1 = &forumSearchRequestV1
	return r
}

func (r ApiSearchForumPostRequest) Execute() (*ForumSearchResponseV1, *http.Response, error) {
	return r.ApiService.SearchForumPostExecute(r)
}

/*
SearchForumPost search forum

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSearchForumPostRequest
*/
func (a *ForumAPIService) SearchForumPost(ctx context.Context) ApiSearchForumPostRequest {
	return ApiSearchForumPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ForumSearchResponseV1
func (a *ForumAPIService) SearchForumPostExecute(r ApiSearchForumPostRequest) (*ForumSearchResponseV1, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ForumSearchResponseV1
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ForumAPIService.SearchForumPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/forums/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.forumSearchRequestV1 == nil {
		return localVarReturnValue, nil, reportError("forumSearchRequestV1 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.forumSearchRequestV1
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponseV1
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchSpecificForumPostRequest struct {
	ctx                  context.Context
	ApiService           *ForumAPIService
	forumId              int64
	forumSearchRequestV1 *ForumSearchRequestV1
}

func (r ApiSearchSpecificForumPostRequest) ForumSearchRequestV1(forumSearchRequestV1 ForumSearchRequestV1) ApiSearchSpecificForumPostRequest {
	r.forumSearchRequestV1 = &forumSearchRequestV1
	return r
}

func (r ApiSearchSpecificForumPostRequest) Execute() (*ForumSearchResponseV1, *http.Response, error) {
	return r.ApiService.SearchSpecificForumPostExecute(r)
}

/*
SearchSpecificForumPost search specific forum

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param forumId Forum id
	@return ApiSearchSpecificForumPostRequest
*/
func (a *ForumAPIService) SearchSpecificForumPost(ctx context.Context, forumId int64) ApiSearchSpecificForumPostRequest {
	return ApiSearchSpecificForumPostRequest{
		ApiService: a,
		ctx:        ctx,
		forumId:    forumId,
	}
}

// Execute executes the request
//
//	@return ForumSearchResponseV1
func (a *ForumAPIService) SearchSpecificForumPostExecute(r ApiSearchSpecificForumPostRequest) (*ForumSearchResponseV1, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ForumSearchResponseV1
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ForumAPIService.SearchSpecificForumPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/forums/{forum_id}/search"
	localVarPath = strings.Replace(localVarPath, "{"+"forum_id"+"}", url.PathEscape(parameterValueToString(r.forumId, "forumId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.forumSearchRequestV1 == nil {
		return localVarReturnValue, nil, reportError("forumSearchRequestV1 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.forumSearchRequestV1
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponseV1
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchSpecificTopicPostRequest struct {
	ctx                  context.Context
	ApiService           *ForumAPIService
	forumId              int64
	topicId              int64
	forumSearchRequestV1 *ForumSearchRequestV1
}

func (r ApiSearchSpecificTopicPostRequest) ForumSearchRequestV1(forumSearchRequestV1 ForumSearchRequestV1) ApiSearchSpecificTopicPostRequest {
	r.forumSearchRequestV1 = &forumSearchRequestV1
	return r
}

func (r ApiSearchSpecificTopicPostRequest) Execute() (*ForumSearchResponseV1, *http.Response, error) {
	return r.ApiService.SearchSpecificTopicPostExecute(r)
}

/*
SearchSpecificTopicPost search specific topic

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param forumId Forum id
	@param topicId Topic id
	@return ApiSearchSpecificTopicPostRequest
*/
func (a *ForumAPIService) SearchSpecificTopicPost(ctx context.Context, forumId int64, topicId int64) ApiSearchSpecificTopicPostRequest {
	return ApiSearchSpecificTopicPostRequest{
		ApiService: a,
		ctx:        ctx,
		forumId:    forumId,
		topicId:    topicId,
	}
}

// Execute executes the request
//
//	@return ForumSearchResponseV1
func (a *ForumAPIService) SearchSpecificTopicPostExecute(r ApiSearchSpecificTopicPostRequest) (*ForumSearchResponseV1, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ForumSearchResponseV1
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ForumAPIService.SearchSpecificTopicPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/forums/{forum_id}/topics/{topic_id}/search"
	localVarPath = strings.Replace(localVarPath, "{"+"forum_id"+"}", url.PathEscape(parameterValueToString(r.forumId, "forumId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic_id"+"}", url.PathEscape(parameterValueToString(r.topicId, "topicId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.forumSearchRequestV1 == nil {
		return localVarReturnValue, nil, reportError("forumSearchRequestV1 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.forumSearchRequestV1
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponseV1
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiShowLogPostRequest struct {
	ctx                              context.Context
	ApiService                       *ForumAPIService
	forumAdminHistorySearchRequestV1 *ForumAdminHistorySearchRequestV1
}

func (r ApiShowLogPostRequest) ForumAdminHistorySearchRequestV1(forumAdminHistorySearchRequestV1 ForumAdminHistorySearchRequestV1) ApiShowLogPostRequest {
	r.forumAdminHistorySearchRequestV1 = &forumAdminHistorySearchRequestV1
	return r
}

func (r ApiShowLogPostRequest) Execute() (*ForumAdminHistorySearchResponseV1, *http.Response, error) {
	return r.ApiService.ShowLogPostExecute(r)
}

/*
ShowLogPost show forum admin log

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiShowLogPostRequest
*/
func (a *ForumAPIService) ShowLogPost(ctx context.Context) ApiShowLogPostRequest {
	return ApiShowLogPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ForumAdminHistorySearchResponseV1
func (a *ForumAPIService) ShowLogPostExecute(r ApiShowLogPostRequest) (*ForumAdminHistorySearchResponseV1, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ForumAdminHistorySearchResponseV1
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ForumAPIService.ShowLogPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/forums/log"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.forumAdminHistorySearchRequestV1 == nil {
		return localVarReturnValue, nil, reportError("forumAdminHistorySearchRequestV1 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.forumAdminHistorySearchRequestV1
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponseV1
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdatePostRequest struct {
	ctx                    context.Context
	ApiService             *ForumAPIService
	forumId                int64
	topicId                int64
	postId                 int64
	forumPostModelUpdateV1 *ForumPostModelUpdateV1
}

func (r ApiUpdatePostRequest) ForumPostModelUpdateV1(forumPostModelUpdateV1 ForumPostModelUpdateV1) ApiUpdatePostRequest {
	r.forumPostModelUpdateV1 = &forumPostModelUpdateV1
	return r
}

func (r ApiUpdatePostRequest) Execute() (*ApiResponseV1, *http.Response, error) {
	return r.ApiService.UpdatePostExecute(r)
}

/*
UpdatePost update a forum post

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param forumId Forum id
	@param topicId Topic id
	@param postId Post id
	@return ApiUpdatePostRequest
*/
func (a *ForumAPIService) UpdatePost(ctx context.Context, forumId int64, topicId int64, postId int64) ApiUpdatePostRequest {
	return ApiUpdatePostRequest{
		ApiService: a,
		ctx:        ctx,
		forumId:    forumId,
		topicId:    topicId,
		postId:     postId,
	}
}

// Execute executes the request
//
//	@return ApiResponseV1
func (a *ForumAPIService) UpdatePostExecute(r ApiUpdatePostRequest) (*ApiResponseV1, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApiResponseV1
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ForumAPIService.UpdatePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/forums/{forum_id}/topics/{topic_id}/posts/{post_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"forum_id"+"}", url.PathEscape(parameterValueToString(r.forumId, "forumId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic_id"+"}", url.PathEscape(parameterValueToString(r.topicId, "topicId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"post_id"+"}", url.PathEscape(parameterValueToString(r.postId, "postId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.forumPostModelUpdateV1 == nil {
		return localVarReturnValue, nil, reportError("forumPostModelUpdateV1 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.forumPostModelUpdateV1
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponseV1
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateTopicRequest struct {
	ctx                     context.Context
	ApiService              *ForumAPIService
	forumId                 int64
	topicId                 int64
	forumTopicModelUpdateV1 *ForumTopicModelUpdateV1
}

func (r ApiUpdateTopicRequest) ForumTopicModelUpdateV1(forumTopicModelUpdateV1 ForumTopicModelUpdateV1) ApiUpdateTopicRequest {
	r.forumTopicModelUpdateV1 = &forumTopicModelUpdateV1
	return r
}

func (r ApiUpdateTopicRequest) Execute() (*ApiResponseV1, *http.Response, error) {
	return r.ApiService.UpdateTopicExecute(r)
}

/*
UpdateTopic update a forum topic

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param forumId Forum id
	@param topicId Topic id
	@return ApiUpdateTopicRequest
*/
func (a *ForumAPIService) UpdateTopic(ctx context.Context, forumId int64, topicId int64) ApiUpdateTopicRequest {
	return ApiUpdateTopicRequest{
		ApiService: a,
		ctx:        ctx,
		forumId:    forumId,
		topicId:    topicId,
	}
}

// Execute executes the request
//
//	@return ApiResponseV1
func (a *ForumAPIService) UpdateTopicExecute(r ApiUpdateTopicRequest) (*ApiResponseV1, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApiResponseV1
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ForumAPIService.UpdateTopic")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/forums/{forum_id}/topics/{topic_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"forum_id"+"}", url.PathEscape(parameterValueToString(r.forumId, "forumId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic_id"+"}", url.PathEscape(parameterValueToString(r.topicId, "topicId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.forumTopicModelUpdateV1 == nil {
		return localVarReturnValue, nil, reportError("forumTopicModelUpdateV1 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.forumTopicModelUpdateV1
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponseV1
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateTopicPollRequest struct {
	ctx                    context.Context
	ApiService             *ForumAPIService
	forumId                int64
	topicId                int64
	forumPollModelUpdateV1 *ForumPollModelUpdateV1
}

func (r ApiUpdateTopicPollRequest) ForumPollModelUpdateV1(forumPollModelUpdateV1 ForumPollModelUpdateV1) ApiUpdateTopicPollRequest {
	r.forumPollModelUpdateV1 = &forumPollModelUpdateV1
	return r
}

func (r ApiUpdateTopicPollRequest) Execute() (*ApiResponseV1, *http.Response, error) {
	return r.ApiService.UpdateTopicPollExecute(r)
}

/*
UpdateTopicPoll update a forum topic poll (if present)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param forumId Forum id
	@param topicId Topic id
	@return ApiUpdateTopicPollRequest
*/
func (a *ForumAPIService) UpdateTopicPoll(ctx context.Context, forumId int64, topicId int64) ApiUpdateTopicPollRequest {
	return ApiUpdateTopicPollRequest{
		ApiService: a,
		ctx:        ctx,
		forumId:    forumId,
		topicId:    topicId,
	}
}

// Execute executes the request
//
//	@return ApiResponseV1
func (a *ForumAPIService) UpdateTopicPollExecute(r ApiUpdateTopicPollRequest) (*ApiResponseV1, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApiResponseV1
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ForumAPIService.UpdateTopicPoll")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/forums/{forum_id}/topics/{topic_id}/poll"
	localVarPath = strings.Replace(localVarPath, "{"+"forum_id"+"}", url.PathEscape(parameterValueToString(r.forumId, "forumId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic_id"+"}", url.PathEscape(parameterValueToString(r.topicId, "topicId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.forumPollModelUpdateV1 == nil {
		return localVarReturnValue, nil, reportError("forumPollModelUpdateV1 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.forumPollModelUpdateV1
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponseV1
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateUserWarnLevelRequest struct {
	ctx                    context.Context
	ApiService             *ForumAPIService
	userId                 int64
	forumWarnModelUpdateV1 *ForumWarnModelUpdateV1
}

func (r ApiUpdateUserWarnLevelRequest) ForumWarnModelUpdateV1(forumWarnModelUpdateV1 ForumWarnModelUpdateV1) ApiUpdateUserWarnLevelRequest {
	r.forumWarnModelUpdateV1 = &forumWarnModelUpdateV1
	return r
}

func (r ApiUpdateUserWarnLevelRequest) Execute() (*ApiResponseV1, *http.Response, error) {
	return r.ApiService.UpdateUserWarnLevelExecute(r)
}

/*
UpdateUserWarnLevel update a user warn level

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId User id
	@return ApiUpdateUserWarnLevelRequest
*/
func (a *ForumAPIService) UpdateUserWarnLevel(ctx context.Context, userId int64) ApiUpdateUserWarnLevelRequest {
	return ApiUpdateUserWarnLevelRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
	}
}

// Execute executes the request
//
//	@return ApiResponseV1
func (a *ForumAPIService) UpdateUserWarnLevelExecute(r ApiUpdateUserWarnLevelRequest) (*ApiResponseV1, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApiResponseV1
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ForumAPIService.UpdateUserWarnLevel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/forums/warn/{user_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.forumWarnModelUpdateV1 == nil {
		return localVarReturnValue, nil, reportError("forumWarnModelUpdateV1 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.forumWarnModelUpdateV1
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponseV1
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
